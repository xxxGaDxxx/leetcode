//
// Учитывая целое число x, вернуть, trueе сли xэто целое число палиндрома.
//
//     Целое число является палиндромом , если оно читается так же, как в прямом, так и в обратном порядке.
//
//     Например, 121есть палиндром, а 123нет.
//
//
//     Пример 1:
//
// Ввод: x = 121
// Вывод: true
// Объяснение: 121 читается как 121 слева направо и справа налево.
//     Пример 2:
//
// Ввод: x = -121
// Вывод: false
// Объяснение: Слева направо читается -121. Справа налево получается 121-. Следовательно, это не палиндром.
//     Пример 3:
//
// Ввод: x = 10
// Вывод: false
// Объяснение: 01 читается справа налево. Следовательно, это не палиндром.


// let isPalindrome = function (x) {
//     let a = String(x)
//     let b = a.split('').reverse().join('')
//     return a===b
// };
// console.log(isPalindrome(121))
// console.log(isPalindrome(123))
// console.log(isPalindrome(12))
// console.log(isPalindrome(11))

// Вам дано большое целое число , представленное в виде массива целых чисел digits, где каждое число digits[i]является цифрой целого числа. Цифры упорядочены от наиболее значащего к наименее значащему в порядке слева направо. Большое целое число не содержит начальных символов .ith0
//
// Увеличьте большое целое число на единицу и верните результирующий массив цифр .
//
//
//
//     Пример 1:
//
// Ввод: цифры = [1,2,3]
// Вывод: [1,2,4]
// Объяснение: Массив представляет целое число 123.
// Увеличение на единицу дает 123 + 1 = 124.
// Таким образом, результат должен быть [1,2,4].
//     Пример 2:
//
// Ввод: цифры = [4,3,2,1]
// Вывод: [4,3,2,2]
// Объяснение: Массив представляет целое число 4321.
// Увеличение на единицу дает 4321 + 1 = 4322.
// Таким образом, результат должен быть [4,3,2,2].

// let plusOne = function(digits) {
//     let a=''
//     for (let i = 0; i < digits.length; i++) {
//         a = a+digits[i]
//     }
//     let b = BigInt(a)+1n
//     return String(b).split('')
// };
//
//
// console.log(plusOne([1,2,3]))
// console.log(plusOne([4,3,2,1]))
// console.log(plusOne([6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]))


// Вам даны два массива целых чисел nums1и nums2, отсортированные в неубывающем порядке , и два целых числа mи n, представляющие количество элементов в nums1и nums2соответственно.
//
//     Объединить nums1 и nums2в один массив, отсортированный в неубывающем порядке .
//
//     Окончательный отсортированный массив не должен возвращаться функцией, а должен храниться внутри массиваnums1 . Чтобы приспособиться к этому, nums1имеет длину m + n, где первые mэлементы обозначают элементы, которые должны быть объединены, а последние nэлементы установлены 0и должны игнорироваться. nums2имеет длину n.
//
//
//
//     Пример 1:
//
// Ввод: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
// Вывод: [1,2,2,3,5,6]
// Объяснение: мы объединяем массивы [1,2,3] и [2,5,6].
//     Результатом слияния является [ 1 , 2 ,2, 3 ,5,6] с подчеркнутыми элементами, исходящими из nums1.
//     Пример 2:
//
// Ввод: nums1 = [1], m = 1, nums2 = [], n = 0
// Вывод: [1]
// Объяснение: Мы объединяем массивы [1] и [].
//     Результат слияния [1].


// let merge = function(nums1, m, nums2, n) {
// if( n === 0 ){
//     console.log(1)
//     return nums1
// }
// if(m === 0){
//     console.log(2)
//    nums1.splice(0,n,...nums2)
//     return nums1
// }
// nums1.splice(m,n,...nums2)
//     return nums1.sort((a,b)=>a-b)
//
// };
//
// console.log(merge([1,2,3,0,0,0],3,[2,5,6],3))
// console.log(merge([1],1,[],0))
// console.log(merge([0],0,[2],1))







